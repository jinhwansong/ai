# AI 경제 브리핑 서비스 – 설계 중심 README
사용자를 대신 판단하지 않고, **뉴스/지수/섹터를 한눈에 정리**해 초보자도 “오늘 시장이 어떤지”를 빠르게 파악하게 하는 서비스입니다. 이 문서는 “무엇을 썼는가”가 아니라 “왜 그렇게 설계했는가”에 초점을 맞춥니다.

## 1. 프로젝트 개요
- 로그인/개인화 없이도, 한 페이지에서 “오늘 시장 흐름”을 빠르게 전달하는 브리핑 서비스
- 실시간 지수(라이브)와 AI 코멘트(배치)를 **혼합**해 최신성+맥락을 동시에 제공
- AI는 **판단 주체가 아닌 ‘정보 정리/관찰’ 도구**로 제한

## 2. 문제 정의 (왜 만들었나)
- 초보자는 뉴스가 많아도 “오늘 무엇을 봐야 하는지” 모름
- AI가 판단 주체처럼 보이는 서비스는 책임·신뢰 문제가 큼
- 지수/뉴스/섹터/관찰 대상이 흩어져 있어 “한눈에” 파악하기 어려움
→ **AI를 해석 보조 도구로 제한**하고, 정보 흐름을 위→아래로 설계하여 초보자도 빠르게 이해하도록 목표 설정

## 3. 해결 전략 (AI를 어떻게/어디까지 썼나)
- 뉴스·지수 기반 **요약/정리/태깅**: 핵심 뉴스, 섹터 요약, 한 줄 인사이트, 관찰 대상
- 글로벌 지수 **한 줄 코멘트** 생성 (배치 결과와 라이브 수치 병합)
- **사용 모델**: Google Gemini 1.5 Flash(주요 요약/전략), GPT(보조 요약) → 비용/속도/품질 균형
- **프롬프트 분리**: 초기 단일 프롬프트 → 섹션별 프롬프트로 분리해 품질·시간 최적화
- AI가 하지 않는 것: 투자 판단, 매수/매도 추천, 단정적 문구
- UX 장치: 최초 1회 모달(“AI는 참고용”), 섹션 헤더 툴팁, 관찰형 톤 가이드

## 4. 기술 스택 선택 이유
- **Next.js (App Router)**  
  - 선택 이유: 파일 기반 라우팅, SSG/ISR/Edge 대응, Vercel 배포와 자연스러운 궁합  
  - 비교/장단점: CRA 대비 서버 옵션이 풍부, 페이지 레벨 코드 스플릿 용이  
  - 적합성: 배치 데이터 + 일부 라이브 데이터를 섹션 단위로 렌더하는 구조에 적합
- **TypeScript**  
  - 선택 이유: 프롬프트/응답 스키마 변경이 잦아 타입 안정성이 필수  
  - 비교: JS 대비 초기 비용↑지만 리팩터링·회귀 방지 효과↑  
  - 적합성: 섹션별 뷰 모델을 명시해 영향 범위 파악 용이
- **TanStack Query**  
  - 선택 이유: 캐싱/로딩/에러 처리 일관화, 섹션별 fetch 로직 분리  
  - 비교: SWR보다 옵션 세분화, suspense 없이 isLoading 제어가 명확  
  - 적합성: 섹션별 스켈레톤을 빠르게 노출, 서버 전환 시에도 용이
- **Tailwind CSS**  
  - 선택 이유: 카드/그리드 중심 UI를 빠르게 토큰화하고 일관성 유지  
  - 비교: CSS-in-JS 대비 번들 부담↓, 디자인 시스템 반영이 단순  
  - 적합성: 빠른 반복과 시각적 일관성을 동시에 확보
- **Supabase (Postgres) + Redis 캐시**  
  - 선택 이유: 배치 결과를 테이블로 저장하고, 최신 스냅샷은 Redis로 빠르게 제공  
  - 비교: Firebase 대비 SQL 스키마 관리 용이, Redis로 초기 응답 지연을 크게 단축  
  - 적합성: “배치 결과 + 라이브 지수” 병합 패턴을 안정적으로 처리

## 5. 폴더 구조와 역할
- **types/**: API/AI 응답과 UI 뷰 모델 타입 분리. 리팩터링 시 타입이 먼저 깨져 영향 범위 파악이 용이.
- **lib/**: 외부 연동(yahooFinance, redis, supabase), 프롬프트 빌더, 서비스 로직. UI와 분리해 순환 의존 방지.
- **util/**: 포맷/시간 등 범용 헬퍼만 배치, 비즈니스 로직과 분리.
- **components/**: 도메인별(main) vs 공용(common) vs 스켈레톤(skeleton)으로 역할 분리. 섹션 헤더/툴팁/스피너는 common, 섹션 UI는 main, 로딩은 skeleton.
- **app/**: 라우팅/페이지 컴포지션만 담당. 데이터 fetch는 섹션 내부 훅으로 이동시켜 로딩/에러를 국소화.
- **import 방향성**: app → components → lib/util/types. UI에서 lib를 역참조하지 않도록 하여 결합도를 낮춤.
- **확장성**: 새 섹션 추가 시 main/새섹션.tsx + skeleton/새섹션Skeleton.tsx + 필요한 hook만 추가하면 되므로 영향 범위 최소.

## 6. 핵심 기능 설계
- **SignalHighlight**: 오늘의 핵심 포인트(문구/태그/영향 맵). 초보자가 한눈에 “오늘 관찰 포인트”를 알게 함.
- **GlobalMacro**: 4개 지수(KOSPI/NASDAQ/Nikkei/Euro Stoxx) 라이브 수치 + AI 코멘트(배치). 팩트/AI를 시각적으로 분리.
- **NewsFeed**: 영향도(High/Medium/Low) 라벨 + 섹터 태그. “왜 중요한가”를 한 문장으로 제공.
- **SectorStrategy**: 모멘텀/스탠스/액션 가이드 상위 3개만 노출(뉴스 연관도+점수화 로직).
- **Observation**: 주목 종목/ETF 3개, 선정 이유/모멘텀/태그.
- **Insight**: AI 한 줄 요약(관찰형 문장). 단정 금지.
- **NoticeModal + 툴팁**: 최초 1회 “AI는 참고용” 안내, 섹션마다 반복 툴팁으로 인지 강화.

## 7. 신뢰성과 판단 책임 분리 설계
- **AI 역할 제한**: 요약/정리/태깅만 수행, 투자 판단 문구 금지.
- **UX 장치**: 최초 모달 + 헤더 툴팁 + 관찰형 톤 가이드로 반복 고지.
- **팩트 vs AI 분리**: 지수/뉴스는 사실, 코멘트는 AI 생성임을 색상/레이블로 구분.
- **카피 톤**: “~로 보입니다”, “~을 관찰” 식의 관찰형 표현. 단정/추천 금지.

## 8. 트러블슈팅 및 고민
- **AI 프롬프트 분리**: 초기엔 단일 프롬프트 → 섹션별 프롬프트로 분리해 품질/속도 개선.
- **초기 로딩 성능**: 단일 프롬프트 사용 시 초기 로딩 16,000ms → Redis 캐시 적용 시 397ms → 프롬프트 분리·캐시 최적화 후 현재 초기 로딩 속도: ___ms(측정 예정), Redis 응답은 290ms까지 감소.
- **AI 신뢰성 정의**: “AI는 판단 도구가 아니다”를 전제로, 온보딩 대신 1회 모달 + 섹션 툴팁을 선택.
- **로딩 전략**: react-query suspense 시 서버단 suspend 문제 → suspense 비활성, 섹션 내부 isLoading + 스켈레톤으로 명시적 제어.
- **폴더 경계**: UI와 데이터 연동을 분리해, 새 섹션 추가 시 기존 섹션 영향 없도록 설계.

## 9. 현재 자동화 현황
- **배치 크론 파이프라인**: `vercel.json` 크론 → `/api/internal/run-pipeline` 단일 엔드포인트(뉴스 수집 → 전략 생성 → 브리핑 생성)로 관리.
- **코드 퀄리티 보호 (Husky + commitlint)**: 혼자 작업하더라도 팀 작업 수준의 규율을 유지하려고, 커밋 메시지 규칙/훅을 엄격히 적용. 협업 전환 시 추가 셋업 없이 그대로 활용 가능.

## 10. 개선 예정 사항
- 섹션별 서버 컴포넌트/ISR 도입 검토 (초기 페인트 속도 추가 단축)
- 모바일 터치 친화적 툴팁/모달 개선, 접근성(포커스/ARIA) 강화
- 전략 가이드 문구의 보수적 톤 추가 가이드 (관망/리스크 강조)
- 자동화 고도화:
  - **모니터링/에러 자동화**: Sentry 도입 예정 (API/배치 에러 알림, 성능 트레이스)
  - **추가 제안**: Lighthouse CI로 빌드 후 성능 회귀 감시
